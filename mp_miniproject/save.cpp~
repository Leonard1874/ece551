#include "commandshell.hpp"

void freecmd(size_t argc, char * args[]) {
  for (size_t i = 0; i < argc; i++) {
    free(args[i]);
  }
}
/*
size_t parse_command(char * line, char * args[]) {
  size_t i = 0;
  std::string command;
  while (line[i] != '\0') {
    if (line[i] == ' ') {
      if (i != 0 && line[i - 1] != ' ') {
        break;
      }
      else {
        i++;
      }
    }
    else {
      command.push_back(line[i]);
      i++;
    }
  }
  args[0] = strdup(command.c_str());
  return i;
}

size_t parse_args(char * line, size_t start, char * args[]) {
  size_t i = start;
  size_t argc = 1;
  while (line[i] != '\0') {
    if (line[i] == ' ') {
      i++;
    }
    else {
      size_t j = i;
      std::string arg;
      while (line[j] != '\0' && line[j] != ' ') {
        arg.push_back(line[j]);
        j++;
      }
      args[argc] = strdup(arg.c_str());
      argc++;
      i = j;
    }
  }
  return argc;
}
*/
/*
int quote_check(bool * quote_closed, size_t * quote_index, char * line) {
  *quote_closed = !(*quote_closed);
  if ((!quote_closed && *quote_index != 0 && line[*quote_index - 1] != ' ') ||
      (*quote_closed && line[*quote_index + 1] != '\0' &&
       line[*quote_index + 1] != ' ')) {
    std::cerr << "wrong position for quote mark!" << std::endl;
    return -1;
  }
  (*quote_index)++;
  if (line[*quote_index] == '\0') {
    return 0;
  }
  if (line[*quote_index] == '"') {
    *quote_closed = !(*quote_closed);
    (*quote_index)++;
    return 0;
  }
  return 1;
}
*/
int command_shell::parse(char * line, char * args[], size_t * argc) {
  size_t i = 0;
  bool isempty = true;
  bool quote_closed = true;
  bool escaping = false;
  while (line[i] != '\0') {
    if (line[i] == ' ') {
      i++;
    }
    else {
      size_t j = i;
      std::string arg;
      while (line[j] != '\0') {
        if (line[j] == '"' && !escaping) {
          quote_closed = !quote_closed;
          j++;
          if (line[j] == '\0') {
            break;
          }
          if (line[j] == '"') {
            quote_closed = !(quote_closed);
            j++;
            break;
          }
        }

        if (line[j] == '\\') {
          if (line[j + 1] == '\0' || (line[j + 1] != '"' && line[j + 1] != '\\')) {
            std::cerr << "unknown gramma of \\, only \" and \\ is allowed." << std::endl;
            return EXIT_FAILURE;
          }
          else {
            escaping = true;
            j++;
          }
        }

        if (quote_closed && (line[j] == ' ' || line[j] == '\0')) {
          break;
        }
        arg.push_back(line[j]);
        if (*argc == 0 && line[j] != ' ') {
          isempty = false;
        }
        if (line[j] == '"' || line[j] == '\\') {
          escaping = false;
        }
        j++;
      }
      if (!arg.empty()) {
        args[*argc] = strdup(arg.c_str());
        (*argc)++;
      }
      i = j;
    }
  }
  if (isempty) {
    std::cerr << "empty command!" << std::endl;
    return EXIT_FAILURE;
  }
  if (!quote_closed) {
    std::cerr << "quote unclosed!" << std::endl;
    return EXIT_FAILURE;
  }
  else {
    return EXIT_SUCCESS;
  }
}

void command_shell::execute(size_t argc, char * args[]) {
  pid_t cpid, w;
  int wstatus = 0;
  char * envs[] = {NULL};
  args[argc] = NULL;
  cpid = fork();
  if (cpid == -1) {
    std::perror("fork fault");
    exit(EXIT_FAILURE);
  }
  else if (cpid == 0) {
    execve(args[0], args, envs);
    std::perror("execve fault");
    freecmd(argc, args);
    exit(EXIT_FAILURE);
  }
  else {
    w = waitpid(cpid, &wstatus, WUNTRACED | WCONTINUED);
    if (w == -1) {
      std::perror("waitpid fault");
      exit(EXIT_FAILURE);
    }
    else {
      if (WIFEXITED(wstatus)) {
        if (WEXITSTATUS(wstatus) == 0) {
          std::cout << "Program was successful" << std::endl;
        }
        else {
          std::cerr << "Program failed with code " << WEXITSTATUS(wstatus) << std::endl;
        }
      }
      if (WIFSIGNALED(wstatus)) {
        std::cerr << "Terminated by signal " << WTERMSIG(wstatus) << std::endl;
      }
    }
  }
}

int command_shell::ffosh() {
  while (true) {
    char * ECE551PATH = getenv("PATH");
    std::cout << "ffosh$";
    std::string command_string;
    std::getline(std::cin, command_string);
    char * command_line = strdup(command_string.c_str());
    if (!std::cin.good()) {
      free(command_line);
      break;
    }
    else if (!strcmp(command_line, "exit")) {
      free(command_line);
      break;
    }
    else {
      char * args[256];
      size_t argc = 0;
      if (parse(command_line, args, &argc)) {
        std::cerr << "command line format error!" << std::endl;
      }
      else {
        //for (size_t i = 0; i < argc; i++) {
        //std::cout << args[i] << std::endl;
        //}
        if (strchr(command_line, '/') == NULL) {
          search_and_exe<true>(argc, args, ECE551PATH);
        }
        else {
          search_and_exe<false>(argc, args, ECE551PATH);
        }
      }
      freecmd(argc, args);
    }
    free(command_line);
  }
  return EXIT_SUCCESS;
}

int main(void) {
  command_shell cs;
  cs.ffosh();
  return EXIT_SUCCESS;
}
